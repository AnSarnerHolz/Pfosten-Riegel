<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>6 m Cutting Plan (No Kerf) — Bin Packing</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script>
    // Utility: download a CSV file
    function downloadCSV(filename, rows) {
      const process = (r) => r.map(v => {
        if (v == null) return '';
        const s = String(v);
        if (s.includes(',') || s.includes('\n') || s.includes('"')) {
          return '"' + s.replace(/"/g, '""') + '"';
        }
        return s;
      }).join(',');
      const csv = rows.map(process).join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', filename);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    // Core solver: repeated bounded knapsack using binary-split expansion
    function planCuts(demand, stockLengthM = 6.0) {
      const stockMM = Math.round(stockLengthM * 1000);

      // Convert demand keys to mm integers
      // demand: array of {lengthM: number, qty: number}
      const items = demand
        .filter(r => r.lengthM > 0 && r.qty > 0)
        .map(r => ({ L: Math.round(r.lengthM * 1000), qty: Math.max(0, Math.floor(r.qty)) }))
        .sort((a, b) => b.L - a.L); // sort desc by length (optional)

      if (items.length === 0) return { bars: [], summary: { totalBars: 0, totalWasteM: 0 } };

      const remaining = new Map(items.map(it => [it.L, it.qty]));
      const bars = [];

      function anyRemaining() {
        for (const [, q] of remaining) if (q > 0) return true;
        return false;
      }

      function boundedKnapsack() {
        // Binary-split bounded items to 0/1 chunks
        const weights = []; // weight = length (mm)
        const payload = []; // payload entry = {Ltrue, countInChunk}

        for (const { L, qty } of items) {
          let q = remaining.get(L) || 0;
          let k = 1;
          while (q > 0) {
            const take = Math.min(k, q);
            weights.push(L * take);
            payload.push({ Ltrue: L, cnt: take });
            q -= take;
            k *= 2;
          }
        }
        if (!weights.length) return null;

        const cap = stockMM;
        const dp = new Int32Array(cap + 1).fill(-1);
        dp[0] = 0;
        const choice = new Int32Array(cap + 1).fill(-1);

        for (let idx = 0; idx < weights.length; idx++) {
          const w = weights[idx];
          for (let c = cap; c >= w; c--) {
            if (dp[c - w] !== -1) {
              const cand = dp[c - w] + w;
              if (cand > dp[c]) {
                dp[c] = cand;
                choice[c] = idx;
              }
            }
          }
        }

        // pick best capacity
        let bestC = 0;
        for (let c = 1; c <= cap; c++) if (dp[c] > dp[bestC]) bestC = c;
        if (dp[bestC] <= 0) return null;

        // reconstruct
        const cutCounts = new Map(); // Ltrue -> count
        let c = bestC;
        while (c > 0 && choice[c] !== -1) {
          const idx = choice[c];
          const w = weights[idx];
          const { Ltrue, cnt } = payload[idx];
          cutCounts.set(Ltrue, (cutCounts.get(Ltrue) || 0) + cnt);
          c -= w;
        }
        if (cutCounts.size === 0) return null;
        return cutCounts; // Map
      }

      while (anyRemaining()) {
        let picks = boundedKnapsack();
        if (!picks) {
          // Fallback: add one longest remaining piece
          let longest = -1;
          for (const [L, q] of remaining) if (q > 0) longest = Math.max(longest, L);
          if (longest === -1) break;
          picks = new Map([[longest, 1]]);
        }

        // compute used and waste
        let used = 0;
        let pieces = [];
        for (const [L, cnt] of picks) {
          used += L * cnt;
          pieces.push({ L, cnt });
        }
        if (used > stockMM) {
          // very unlikely since knapsack respects capacity, but safe-guard
          // shrink smallest pieces until fits
          pieces.sort((a, b) => a.L - b.L);
          while (used > stockMM && pieces.length) {
            const p = pieces[0];
            p.cnt -= 1;
            used -= p.L;
            if (p.cnt <= 0) pieces.shift();
          }
          // rebuild picks map
          picks = new Map();
          for (const p of pieces) picks.set(p.L, p.cnt);
        }

        const waste = stockMM - used;
        // record bar
        bars.push({ picks: new Map(picks), waste });
        // decrement remaining
        for (const [L, cnt] of picks) {
          remaining.set(L, Math.max(0, (remaining.get(L) || 0) - cnt));
        }
      }

      const summary = {
        totalBars: bars.length,
        totalWasteM: bars.reduce((acc, b) => acc + b.waste, 0) / 1000
      };
      return { bars, summary };
    }

    function humanCuts(picks) {
      const arr = Array.from(picks.entries())
        .sort((a, b) => b[0] - a[0])
        .map(([L, cnt]) => `${cnt}×${(L / 1000).toFixed(3)}m`);
      return arr.join(' + ');
    }

    function runSolver() {
      // Read table rows
      const tbody = document.querySelector('#demandBody');
      const rows = Array.from(tbody.querySelectorAll('tr'));
      const demand = [];
      for (const tr of rows) {
        const len = parseFloat(tr.querySelector('.len').value);
        const qty = parseInt(tr.querySelector('.qty').value, 10);
        if (!isFinite(len) || !isFinite(qty)) continue;
        if (len > 0 && qty > 0) demand.push({ lengthM: len, qty });
      }
      const { bars, summary } = planCuts(demand, 6.0);

      // Render results
      const out = document.querySelector('#resultsBody');
      out.innerHTML = '';
      bars.forEach((bar, i) => {
        const tr = document.createElement('tr');
        const usedM = ( (6000 - bar.waste) / 1000 ).toFixed(3);
        const wasteM = (bar.waste / 1000).toFixed(3);
        tr.innerHTML = `
          <td class="cell">${i + 1}</td>
          <td class="cell">${humanCuts(bar.picks)}</td>
          <td class="cell right">${usedM}</td>
          <td class="cell right">${wasteM}</td>
        `;
        out.appendChild(tr);
      });

      document.querySelector('#summaryBars').textContent = summary.totalBars;
      document.querySelector('#summaryWaste').textContent = summary.totalWasteM.toFixed(3);

      // Enable CSV download
      document.querySelector('#btnCSV').onclick = () => {
        const rows = [["Bar #","Cuts","Used (m)","Waste (m)"]];
        bars.forEach((bar, i) => {
          const usedM = ((6000 - bar.waste)/1000).toFixed(3);
          const wasteM = (bar.waste/1000).toFixed(3);
          rows.push([i+1, humanCuts(bar.picks), usedM, wasteM]);
        });
        downloadCSV('cutting_plan.csv', rows);
      };
    }

    function addRow(len = '', qty = '') {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td class="cell"><input class="len" type="number" step="0.001" min="0" value="${len}"></td>
        <td class="cell"><input class="qty" type="number" step="1" min="0" value="${qty}"></td>
        <td class="cell"><button class="ghost" onclick="this.closest('tr').remove();">✕</button></td>
      `;
      document.querySelector('#demandBody').appendChild(tr);
    }

    function loadExample() {
      const demo = [
        { lengthM: 0.5, qty: 20 },
        { lengthM: 1.0, qty: 12 },
        { lengthM: 1.7, qty: 34 },
        { lengthM: 2.0, qty: 4 }
      ];
      const tbody = document.querySelector('#demandBody');
      tbody.innerHTML = '';
      demo.forEach(r => addRow(r.lengthM, r.qty));
    }

    window.addEventListener('DOMContentLoaded', () => {
      loadExample();
      document.querySelector('#btnAdd').addEventListener('click', () => addRow());
      document.querySelector('#btnSolve').addEventListener('click', runSolver);
      document.querySelector('#btnCSV').addEventListener('click', () => {});
      document.querySelector('#btnClear').addEventListener('click', () => {
        document.querySelector('#resultsBody').innerHTML = '';
        document.querySelector('#summaryBars').textContent = '0';
        document.querySelector('#summaryWaste').textContent = '0.000';
      });
    });
  </script>
  <style>
    :root { --bg: #0b0f19; --panel: #121829; --ink: #e5e7eb; --muted: #9aa4b2; --accent: #60a5fa; }
    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background: var(--bg); color: var(--ink); }
    .container { max-width: 1100px; margin: 40px auto; padding: 0 16px; }
    .card { background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border: 1px solid rgba(255,255,255,0.08); border-radius: 18px; box-shadow: 0 10px 30px rgba(0,0,0,0.25); }
    header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
    h1 { font-size: 24px; margin: 0; letter-spacing: 0.2px; }
    p.sub { color: var(--muted); margin: 6px 0 0; font-size: 14px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }

    .panel { padding: 16px; }
    .panel h2 { font-size: 16px; margin: 0 0 8px; font-weight: 600; }

    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 10px 12px; border-bottom: 1px dashed rgba(255,255,255,0.08); }
    th { text-align: left; color: var(--muted); font-weight: 500; font-size: 13px; }
    td.cell { font-size: 14px; }
    td.cell.right { text-align: right; }

    input[type="number"] { width: 100%; padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.14); background: #0f1523; color: var(--ink); }

    .toolbar { display: flex; gap: 8px; margin: 8px 0 12px; }
    button { padding: 10px 14px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.12); background: #1a2440; color: var(--ink); cursor: pointer; font-weight: 600; }
    button:hover { border-color: rgba(255,255,255,0.25); }
    button.accent { background: #1b284a; border-color: #2a4b8c; color: #e8f1ff; }
    button.ghost { background: transparent; border: 1px solid rgba(255,255,255,0.14); padding: 6px 10px; }

    .summary { display: flex; gap: 24px; align-items: baseline; margin-top: 8px; color: var(--muted); }
    .summary strong { color: var(--ink); font-size: 18px; margin-left: 6px; }
    footer.note { color: var(--muted); font-size: 12px; margin-top: 16px; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>6 m Cutting Plan (No Kerf)</h1>
        <p class="sub">Heuristic solver using bounded knapsack — combine any lengths per bar as long as they fit within 6.0 m.</p>
      </div>
      <div class="summary">
        <span>Total Bars:<strong id="summaryBars">0</strong></span>
        <span>Total Waste (m):<strong id="summaryWaste">0.000</strong></span>
      </div>
    </header>

    <div class="grid">
      <section class="card panel">
        <h2>Demand</h2>
        <div class="toolbar">
          <button id="btnAdd">+ Add row</button>
          <button id="btnSolve" class="accent">Solve</button>
          <button id="btnCSV">Download CSV</button>
          <button id="btnClear">Clear Results</button>
        </div>
        <table>
          <thead>
            <tr>
              <th>Length (m)</th>
              <th>Quantity</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="demandBody"></tbody>
        </table>
        <footer class="note">Tip: Use decimals (e.g., 0.5 for 50 cm). Kerf/trim are ignored by design.</footer>
      </section>

      <section class="card panel">
        <h2>Cut Plan</h2>
        <table>
          <thead>
            <tr>
              <th>Bar #</th>
              <th>Cuts</th>
              <th class="right">Used (m)</th>
              <th class="right">Waste (m)</th>
            </tr>
          </thead>
          <tbody id="resultsBody"></tbody>
        </table>
        <footer class="note">Each row is one 6 m stock bar. “Cuts” shows piece counts and lengths packed by the solver.</footer>
      </section>
    </div>
  </div>
</body>
</html>
