<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cutting Plan — Custom Stock Length</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script>
    function downloadCSV(filename, rows) {
      const process = (r) => r.map(v => {
        if (v == null) return '';
        const s = String(v);
        if (s.includes(',') || s.includes('\n') || s.includes('"')) {
          return '"' + s.replace(/"/g, '""') + '"';
        }
        return s;
      }).join(',');
      const csv = rows.map(process).join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', filename);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function parseExcelPaste(text) {
      const rows = text.trim().split(/\r?\n/);
      const demand = [];
      for (let line of rows) {
        line = line.replace(/\t/g, ','); // convert tabs to commas
        const parts = line.split(',').map(s => s.trim());
        if (parts.length < 2) continue;
        const len = parseInt(parts[0], 10);
        const qty = parseInt(parts[1], 10);
        if (isFinite(len) && isFinite(qty) && len > 0 && qty > 0) {
          demand.push({ lengthMM: len, qty });
        }
      }
      return demand;
    }

    function planCuts(demand, stockLengthMM) {
      const items = demand
        .filter(r => r.lengthMM > 0 && r.qty > 0)
        .map(r => ({ L: r.lengthMM, qty: Math.max(0, Math.floor(r.qty)) }))
        .sort((a, b) => b.L - a.L);
      if (items.length === 0) return { bars: [], summary: { totalBars: 0, totalWasteMM: 0 } };
      const remaining = new Map(items.map(it => [it.L, it.qty]));
      const bars = [];
      function anyRemaining() { for (const [, q] of remaining) if (q > 0) return true; return false; }
      function boundedKnapsack() {
        const weights = [], payload = [];
        for (const { L, qty } of items) {
          let q = remaining.get(L) || 0, k = 1;
          while (q > 0) { const take = Math.min(k,q); weights.push(L*take); payload.push({Ltrue:L,cnt:take}); q-=take; k*=2; }
        }
        if (!weights.length) return null;
        const cap = stockLengthMM;
        const dp = new Int32Array(cap+1).fill(-1); dp[0]=0;
        const choice = new Int32Array(cap+1).fill(-1);
        for (let idx=0; idx<weights.length; idx++){const w=weights[idx]; for(let c=cap;c>=w;c--){if(dp[c-w]!=-1){const cand=dp[c-w]+w; if(cand>dp[c]){dp[c]=cand; choice[c]=idx;}}}}
        let bestC=0; for(let c=1;c<=cap;c++) if(dp[c]>dp[bestC]) bestC=c;
        if(dp[bestC]<=0) return null;
        const cutCounts=new Map(); let c=bestC;
        while(c>0 && choice[c]!=-1){const idx=choice[c]; const {Ltrue,cnt}=payload[idx]; cutCounts.set(Ltrue,(cutCounts.get(Ltrue)||0)+cnt); c-=weights[idx];}
        if(cutCounts.size===0) return null; return cutCounts;
      }
      while(anyRemaining()){
        let picks=boundedKnapsack();
        if(!picks){let longest=-1; for(const [L,q] of remaining) if(q>0) longest=Math.max(longest,L); if(longest===-1) break; picks=new Map([[longest,1]]);}
        let used=0, pieces=[]; for(const [L,cnt] of picks){used+=L*cnt; pieces.push({L,cnt});}
        if(used>stockLengthMM){pieces.sort((a,b)=>a.L-b.L); while(used>stockLengthMM && pieces.length){const p=pieces[0];p.cnt--; used-=p.L; if(p.cnt<=0) pieces.shift();} picks=new Map(); for(const p of pieces) picks.set(p.L,p.cnt);}
        const waste=stockLengthMM-used;
        bars.push({picks:new Map(picks), waste});
        for(const [L,cnt] of picks) remaining.set(L, Math.max(0,(remaining.get(L)||0)-cnt));
      }
      const summary={totalBars: bars.length, totalWasteMM: bars.reduce((acc,b)=>acc+b.waste,0)};
      return { bars, summary };
    }

    function humanCuts(picks){
      return Array.from(picks.entries()).sort((a,b)=>b[0]-a[0]).map(([L,cnt])=>`${cnt}×${L} mm`).join(' + ');
    }

    function fillDemandTable(demand){
      const tbody=document.querySelector('#demandBody'); tbody.innerHTML='';
      demand.forEach(r=>{
        const tr=document.createElement('tr');
        tr.innerHTML=`<td class="cell"><input class="len" type="number" step="1" min="0" value="${r.lengthMM}"></td>`+
                     `<td class="cell"><input class="qty" type="number" step="1" min="0" value="${r.qty}"></td>`+
                     `<td class="cell"><button class="ghost" onclick="this.closest('tr').remove();">✕</button></td>`;
        tbody.appendChild(tr);
      });
    }

    function runSolver(){
      const tbody=document.querySelector('#demandBody');
      const rows=Array.from(tbody.querySelectorAll('tr'));
      const demand=[];
      for(const tr of rows){
        const len=parseInt(tr.querySelector('.len').value,10);
        const qty=parseInt(tr.querySelector('.qty').value,10);
        if(isFinite(len) && isFinite(qty) && len>0 && qty>0) demand.push({lengthMM:len, qty});
      }
      const stockLengthMM=parseInt(document.querySelector('#stockLength').value,10);
      const {bars,summary}=planCuts(demand,stockLengthMM);
      const out=document.querySelector('#resultsBody'); out.innerHTML='';
      bars.forEach((bar,i)=>{
        const tr=document.createElement('tr');
        const usedMM=(stockLengthMM-bar.waste); const wasteMM=bar.waste;
        tr.innerHTML=`<td class="cell">${i+1}</td><td class="cell">${humanCuts(bar.picks)}</td>`+
                     `<td class="cell right">${usedMM} mm</td><td class="cell right">${wasteMM} mm</td>`;
        out.appendChild(tr);
      });
      document.querySelector('#summaryBars').textContent=summary.totalBars;
      document.querySelector('#summaryWaste').textContent=summary.totalWasteMM+" mm";
      document.querySelector('#btnCSV').onclick=()=>{
        const rows=[["Bar #","Cuts","Used (mm)","Waste (mm)"]];
        bars.forEach((bar,i)=>{ const usedMM=(stockLengthMM-bar.waste); const wasteMM=bar.waste; rows.push([i+1,humanCuts(bar.picks),usedMM,wasteMM]);});
        downloadCSV('cutting_plan.csv',rows);
      };
    }

    function addRow(len='', qty=''){const tr=document.createElement('tr'); tr.innerHTML=`<td class="cell"><input class="len" type="number" step="1" min="0" value="${len}"></td>`+`<td class="cell"><input class="qty" type="number" step="1" min="0" value="${qty}"></td>`+`<td class="cell"><button class="ghost" onclick="this.closest('tr').remove();">✕</button></td>`; document.querySelector('#demandBody').appendChild(tr);}

    function handlePaste(){
      const text=document.querySelector('#pasteBox').value;
      const demand=parseExcelPaste(text);
      fillDemandTable(demand);
    }

    window.addEventListener('DOMContentLoaded',()=>{
      document.querySelector('#btnAdd').addEventListener('click',()=>addRow());
      document.querySelector('#btnSolve').addEventListener('click',runSolver);
      document.querySelector('#btnCSV').addEventListener('click',()=>{});
      document.querySelector('#btnClear').addEventListener('click',()=>{
        document.querySelector('#resultsBody').innerHTML='';
        document.querySelector('#summaryBars').textContent='0';
        document.querySelector('#summaryWaste').textContent='0 mm';
      });
      document.querySelector('#pasteButton').addEventListener('click', handlePaste);
      document.querySelector('#fileInput').addEventListener('change',(event)=>{
        const file=event.target.files[0]; if(!file) return;
        const reader=new FileReader();
        reader.onload=(e)=>{ const demand=parseExcelPaste(e.target.result); fillDemandTable(demand); };
        reader.readAsText(file);
      });
    });
  </script>
  <style>
    :root { --bg: #0b0f19; --panel: #121829; --ink: #e5e7eb; --muted: #
